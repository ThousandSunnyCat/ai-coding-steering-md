---
inclusion: always
---
<!------------------------------------------------------------------------------------
   Add rules to this file or a short description that will apply across all your workspaces.
   
   Learn about inclusion modes: https://kiro.dev/docs/steering/#inclusion-modes
-------------------------------------------------------------------------------------> 

# Kiro 全局设计与开发原则 v3.1 (Agent-Optimized)

## 1. 核心指令 (Core Directive)

本文档是 Kiro 执行软件设计与开发任务的**最高行为准则**。在任何技术决策、架构设计或代码生成中，必须严格遵循以下原则，以确保产出具备**简洁性 (Simplicity)**、**实用性 (Pragmatism)** 和**可维护性 (Maintainability)**。

## 2. 设计原则 (Design Principles)

### 2.1 奥卡姆剃刀原则 (Occam's Razor)
**指令: "如无必要，勿增实体"。在所有可行方案中，永远选择最简单、最直接的那个。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 优先简单技术栈:** 默认使用成熟、稳定的技术。 | **1. 避免过度工程化:** 禁止为未明确的需求设计复杂方案。 |
| **2. 采用最简架构:** 默认从单体/简单分层开始。 | **2. 抵制技术诱惑:** 禁止仅因技术“时髦”而推荐。 |
| **3. 简化数据模型:** 设计最直接的表结构，避免过度冗余。 | **3. 避免不必要抽象:** 禁止将简单函数过度包装。 |
| **4. 主动提出简化方案:** 面对复杂需求，必须思考并提出分阶段的简单实现路径。 | |

---

### 2.2 KISS 原则 (Keep It Simple, Stupid)
**指令: "保持简单、傻瓜化"。代码和系统必须让任何开发者都能快速理解和维护。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 遵循单一职责 (SRP):** 每个模块/类/函数/组件只做一件事。 | **1. 避免“上帝对象”:** 禁止设计包含大量无关功能的巨大类或组件。 |
| **2. 采用清晰命名:** 变量、函数、文件名等必须清晰无歧义，反映其用途。 | **2. 避免隐晦逻辑:** 禁止编写需要揣摩才能理解的代码。复杂逻辑必须简化或注释。 |
| **3. 减少依赖与耦合:** 模块间通过接口通信，优先 props 传参。 | **3. 避免循环依赖:** 严格禁止模块 A 依赖 B，同时 B 依赖 A。 |
| **4. 编写高可读性代码:** 逻辑直接明了，复杂处必须添加注释。 | |

---

### 2.3 YAGNI 原则 (You Aren't Gonna Need It)
**指令: "你不会需要它的"。只实现当前明确要求的功能。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 聚焦当前需求:** 严格围绕已确认的需求进行开发。 | **1. 禁止实现“以防万一”的功能:** 不添加任何基于未来猜测的功能。 |
| **2. 实现最小功能集 (MVP):** 主动识别并只实现最核心的功能路径。 | **2. 禁止创建过多配置项:** 优先使用合理的默认值，而非复杂的配置开关。 |
| **3. 延迟非核心决策:** 将非核心的决策推迟到信息更充分时。 | **3. 禁止过度通用化:** 如果只需要处理一种情况，就不要编写能处理所有情况的复杂代码。 |
| **4. 移除无用代码:** 在重构时，主动扫描并提议删除不再使用的代码。 | |

---

### 2.4 不要重复造轮子 (Don't Reinvent the Wheel)
**指令: "优先使用业界成熟的轮子"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 主动推荐标准库/包:** 针对常见问题（日期、HTTP、路由等），必须推荐并使用社区公认的解决方案。 | **1. 禁止手动实现通用功能:** 严禁从零编写已被广泛解决的功能（如 ORM、日期计算）。 |
| **2. 评估依赖质量:** 推荐第三方包时，必须基于活跃度、文档、更新日期等因素进行评估。 | **2. 禁止引入冷门或过时依赖:** 避免使用维护停滞或有严重漏洞的包。 |
| **3. 封装外部依赖:** 建议通过内部模块封装外部库，以降低耦合。 | **3. 禁止为简单任务引入重型框架:** 避免“杀鸡用牛刀”。 |

---

### 2.5 DRY 原则 (Don't Repeat Yourself)
**指令: "系统中每一处知识都必须有单一、无歧义、权威的表示"。避免任何形式的逻辑重复。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 提取重复逻辑:** 主动扫描并提取重复代码块为可复用单元（函数、组件等）。 | **1. 禁止复制粘贴代码:** 严禁为快速实现而复制并微调代码。 |
| **2. 优先复用现有代码:** 实现新功能前，必须先检查是否存在可复用的相似功能。 | **2. 禁止在多处维护相同逻辑:** 避免在前后端重复实现相同的业务规则（如校验）。 |
| **3. 参数化以增加复用:** 优先通过为现有功能添加参数来满足新需求。 | |
| **4. 统一配置与常量:** 将多处使用的魔法值提取为中心化的常量。 | |

---

### 2.6 高内聚，低耦合 (High Cohesion, Low Coupling)
**指令: "让相关的代码待在一起，让无关的代码保持距离"。这是衡量设计质量的根本标准。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. (高内聚) 组织相关功能:** 将实现同一业务功能的代码组织在同一模块/文件夹中。 | **1. (低内聚) 功能分散:** 避免将单一功能的代码分散到项目各处。 |
| **2. (低耦合) 定义清晰边界:** 模块间必须通过稳定的接口（API, Props）通信。 | **2. (高耦合) 直接访问内部实现:** 严禁一个模块直接访问另一个模块的内部变量或私有函数。 |
| **3. (低耦合) 使用依赖注入:** 模块不应自己创建依赖，应由外部传入。 | **3. (高耦合) 创建循环依赖:** 再次强调，严格禁止循环依赖。 |
| **4. (低耦合) 采用事件/消息传递:** 对非核心或异步通信，优先考虑事件总线或消息队列。 | |

## 3. 应用指南 (Application Guide)

Kiro 必须在所有相关任务中**主动应用**此文档。当建议与这些原则冲突时，必须向用户**明确指出冲突点并解释原因**。
