---
inclusion: always
---
<!------------------------------------------------------------------------------------
   Add rules to this file or a short description that will apply across all your workspaces.
   
   Learn about inclusion modes: https://kiro.dev/docs/steering/#inclusion-modes
-------------------------------------------------------------------------------------> 

# Kiro SOLID 设计原则指南 v1.1 (Agent-Optimized)

## 1. 核心指令 (Core Directive)

本文档是 Kiro 在面向对象和组件化设计中必须遵循的 **SOLID 设计原则**。在生成涉及类、接口、模块或组件的代码时，必须严格应用此指南，以确保代码的**可维护性、可扩展性和可复用性**。

## 2. SOLID 原则指令集

### S - 单一职责原则 (Single Responsibility Principle)
**指令: "一个单元只对一个功能负责"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 识别多重职责:** 扫描类/组件是否承担了多个无关职责（如：数据获取 + 业务逻辑 + UI 渲染）。 | **1. 创建“瑞士军刀”单元:** 禁止设计一个无所不能的、包含多种不相关功能的类或组件。 |
| **2. 主动拆分:** 如果识别到多重职责，必须主动提议并执行拆分，将其分解为多个职责单一的小单元。 | |

---

### O - 开放/封闭原则 (Open/Closed Principle)
**指令: "对扩展开放，对修改封闭"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 识别扩展点:** 当功能点（如支付方式、认证策略）未来可能扩展时，必须采用允许添加新功能而无需修改现有代码的设计。 | **1. 硬编码实现:** 禁止将易变的功能直接硬编码在核心逻辑中。 |
| **2. 应用可扩展模式:** 优先使用**策略模式**、**插件/中间件架构**或**基于接口的扩展**来设计。 | **2. 通过修改旧代码添加新功能:** 避免通过 `if/else` 或 `switch` 不断修改现有代码来支持新类型。 |

---

### L - 里氏替换原则 (Liskov Substitution Principle)
**指令: "子类必须能够替换其父类而不产生错误"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 验证继承契约:** 在生成子类时，必须确保其行为严格遵守父类的“契约”。 | **1. 破坏父类行为:** 禁止子类改变父类已实现方法的功能或抛出未声明的异常。 |
| **2. 检查方法签名:** 确保子类方法的参数类型与父类相同或更宽松，返回类型与父类相同或更严格。 | **2. 限制父类能力:** 禁止子类方法的功能范围比父类方法更窄。 |

---

### I - 接口隔离原则 (Interface Segregation Principle)
**指令: "客户端不应被强迫依赖它不使用的方法"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 设计小而专的接口:** 设计接口（如 Go/TS `interface`）或组件 `props` 时，使其只包含客户端需要的方法/属性。 | **1. 创建“胖接口”:** 禁止设计包含大量方法、导致客户端需要实现其不使用功能的庞大接口。 |
| **2. 拆分大接口:** 如果一个接口变得过于庞大，必须建议并将其拆分为多个更小、更具体的接口。 | |

---

### D - 依赖倒置原则 (Dependency Inversion Principle)
**指令: "高层模块依赖抽象，低层模块实现抽象"。**

| ✅ **执行 (Do)** | ❌ **禁止 (Don't)** |
| :--- | :--- |
| **1. 面向接口编程:** 生成的代码必须优先依赖于接口（抽象），而非具体实现。 | **1. 依赖具体实现:** 禁止高层模块（业务逻辑）直接依赖低层模块（如具体的数据库访问类）。 |
| **2. 使用依赖注入 (DI):** 服务的依赖项（如数据库连接）必须通过外部传入（构造函数、方法参数），而不是在内部直接创建实例。 | **2. 在高层模块中创建低层实例:** 禁止在业务逻辑代码中出现 `new DatabaseConnection()` 这样的硬编码。 |
